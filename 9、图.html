<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    function Queue() {
        //数组方向 <-----,push进去，shift出来
        this.items = []
        //队列尾部添加一个
        Queue.prototype.enter = function (item) {
            this.items.push(item)
        }
        //移除队列头部项，并返回该移除项目
        Queue.prototype.leave = function () {
            return this.items.shift()
        }
        //返回队列第一个元素
        Queue.prototype.first = function () {
            return this.items[0]
        }
        //判断是否为空
        Queue.prototype.isEmpty = function () {
            return this.items.length == 0
        }
        //队列元素个数
        Queue.prototype.size = function () {
            return this.items.length
        }
        //tostring
        Queue.prototype.toString = function () {
            var resultString = '';
            for (let i = 0; i < this.items.length; i++) {
                resultString += this.items[i]
            }
            return resultString
        }
    }
    // 创建字典的构造函数
    function Dictionay() {
        // 字典属性
        this.items = {}

        // 字典操作方法
        // 在字典中添加键值对
        Dictionay.prototype.set = function (key, value) {
            this.items[key] = value
        }

        // 判断字典中是否有某个key
        Dictionay.prototype.has = function (key) {
            return this.items.hasOwnProperty(key)
        }

        // 从字典中移除元素
        Dictionay.prototype.remove = function (key) {
            // 1.判断字典中是否有这个key
            if (!this.has(key)) return false

            // 2.从字典中删除key
            delete this.items[key]
            return true
        }

        // 根据key去获取value
        Dictionay.prototype.get = function (key) {
            return this.has(key) ? this.items[key] : undefined
        }

        // 获取所有的keys
        Dictionay.prototype.keys = function () {
            return Object.keys(this.items)
        }

        // 获取所有的value
        Dictionay.prototype.values = function () {
            return Object.values(this.items)
        }

        // size方法
        Dictionay.prototype.size = function () {
            return this.keys().length
        }

        // clear方法
        Dictionay.prototype.clear = function () {
            this.items = {}
        }
    }

    function Graph() {
        // 属性
        this.vertexes = [] // 存储顶点
        this.adjList = new Dictionay() // 存储边
        //不完美，因为顶点应该用set存储，因为数组的话可能存在重复，也就是顶点重复
        //顶点为数组   顶点和边的形状为{key:[]},key则是顶点的表示
        // 方法
        // 添加方法
        Graph.prototype.addVertex = function (v) {
            this.vertexes.push(v)
            this.adjList.set(v, [])
        }
        //添加边的关系   我里面有你你里面也应该有我
        Graph.prototype.addEdge = function (v, w) {
            this.adjList.get(v).push(w)
            this.adjList.get(w).push(v)
        }
        Graph.prototype.toString = function () {
            var resultStr = ""
            for (var i = 0; i < this.vertexes.length; i++) {
                resultStr += this.vertexes[i] + "->"
                var adj = this.adjList.get(this.vertexes[i])
                for (var j = 0; j < adj.length; j++) {
                    resultStr += adj[j] + " "
                }
                resultStr += "\n"
            }
            return resultStr
        }
        // 广度优先算法   初始化颜色为white色
        //访问过为grey，处理过为black
        Graph.prototype.initializeColor = function () {
            var colors = []
            for (var i = 0; i < this.vertexes.length; i++) {
                colors[this.vertexes[i]] = "white"
            }
            return colors
        }
        Graph.prototype.bfs = function (v, handler) {
            // 1.初始化颜色
            var color = this.initializeColor()
            // 2.创建队列
            var queue = new Queue()
            // 3.将传入的顶点放入队列中
            queue.enqueue(v)
            // 4.从队列中依次取出和放入数据
            while (!queue.isEmpty()) {
                // 4.1.从队列中取出数据
                var qv = queue.dequeue()
                // 4.2.获取qv相邻的所有顶点
                var qAdj = this.adjList.get(qv)
                // 4.3.将qv的颜色设置成灰色
                color[qv] = "gray"
                // 4.4.将qAdj的所有顶点依次压入队列中
                for (var i = 0; i < qAdj.length; i++) {
                    var a = qAdj[i]
                    if (color[a] === "white") {
                        color[a] = "gray"
                        queue.enqueue(a)
                    }
                }
                // 4.5.因为qv已经探测完毕, 将qv设置成黑色
                color[qv] = "black"
                // 4.6.处理qv
                if (handler) {
                    handler(qv)
                }
            }
        }
        // 深度优先搜索
        Graph.prototype.dfs = function (handler) {
            // 1.初始化颜色
            var color = this.initializeColor()
            // 2.遍历所有的顶点, 开始访问
            for (var i = 0; i < this.vertexes.length; i++) {
                if (color[this.vertexes[i]] === "white") {
                    this.dfsVisit(this.vertexes[i], color, handler)
                }
            }
        }
        // dfs的递归调用方法
        Graph.prototype.dfsVisit = function (u, color, handler) {
            // 1.将u的颜色设置为灰色
            color[u] = "gray"
            // 2.处理u顶点
            if (handler) {
                handler(u)
            }
            // 3.u的所有邻接顶点的访问
            var uAdj = this.adjList.get(u)
            for (var i = 0; i < uAdj.length; i++) {
                var w = uAdj[i]
                if (color[w] === "white") {
                    this.dfsVisit(w, color, handler)
                }
            }
            // 4.将u设置为黑色
            color[u] = "black"
        }

    }
</script>

</html>