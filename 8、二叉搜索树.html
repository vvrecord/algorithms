<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    function BinarySearchTree() {
        this.root = null;
        function Node(key) {
            this.key = key;
            this.left = null;
            this.right = null;
        }
        //插入数据
        BinarySearchTree.prototype.insert = function (key) {
            var newNode = new Node(key)
            if (this.root == null) {
                this.root = newNode
            } else {
                this.insertNode(this.root, newNode)
            }
        }
        //封装递归的方法
        BinarySearchTree.prototype.insertNode = function (node, newNode) {
            if (newNode.key < node.key) { //向左找
                if (node.left == null) {
                    node.left = newNode
                } else {
                    this.insertNode(node.left, newNode)
                }
            } else {
                if (node.right == null) {
                    node.right = newNode
                } else {
                    this.insertNode(node.right, newNode)
                }
            }
        }
        //先序遍历
        BinarySerachTree.prototype.preOrderTraversal = function (handler) {
            this.preOrderTranversalNode(this.root, handler)
        }
        BinarySerachTree.prototype.preOrderTranversalNode = function (node, handler) {
            if (node !== null) {
                // 1.打印当前经过的节点
                handler(node.key)
                // 2.遍历所有的左子树
                this.preOrderTranversalNode(node.left, handler)
                // 3.遍历所有的右子树
                this.preOrderTranversalNode(node.right, handler)
            }
        }
        //中序遍历
        // 中序遍历
        BinarySerachTree.prototype.inOrderTraversal = function (handler) {
            this.inOrderTraversalNode(this.root, handler)
        }
        BinarySerachTree.prototype.inOrderTraversalNode = function (node, handler) {
            if (node !== null) {
                this.inOrderTraversalNode(node.left, handler)
                handler(node.key)
                this.inOrderTraversalNode(node.right, handler)
            }
        }
        //后续遍历
        // 后续遍历
        BinarySerachTree.prototype.postOrderTraversal = function (handler) {
            this.postOrderTraversalNode(this.root, handler)
        }
        BinarySerachTree.prototype.postOrderTraversalNode = function (node, handler) {
            if (node !== null) {
                this.postOrderTraversalNode(node.left, handler)
                this.postOrderTraversalNode(node.right, handler)
                handler(node.key)
            }
        }
        //最大值和最小值
        // 获取最大值和最小值
        BinarySerachTree.prototype.min = function () {
            var node = this.root
            while (node.left !== null) {
                node = node.left
            }
            return node.key
        }
        BinarySerachTree.prototype.max = function () {
            var node = this.root
            while (node.right !== null) {
                node = node.right
            }
            return node.key
        }
        //搜素特定的值
        // 搜搜特定的值
        BinarySerachTree.prototype.search = function (key) {
            return this.searchNode(this.root, key)
        }
        BinarySerachTree.prototype.searchNode = function (node, key) {
            // 1.如果传入的node为null那么, 那么就退出递归
            if (node === null) {
                return false
            }
            // 2.判断node节点的值和传入的key大小
            if (node.key > key) { // 2.1.传入的key较小, 向左边继续查找
                return this.searchNode(node.left, key)
            } else if (node.key < key) { // 2.2.传入的key较大, 向右边继续查找
                return this.searchNode(node.right, key)
            } else { // 2.3.相同, 说明找到了key
                return true
            }
        }
        //循环搜素特点的值
        BinarySerachTree.prototype.forSearch = function (key) {
            var node = this.root;
            while (node != null) {
                if (key < node.key) {
                    node = node.left
                } else if (key > node.key) {
                    node = node.right
                } else {
                    return true
                }
            }
            return false;
        }
        //删除
        BinarySerachTree.prototype.remove = function (key) {
            var current = this.root;
            var parent = null;
            var isLeftChild = true;
            //没找到一直循环
            while (current.key != key) {
                parent = current;
                if (key < current.key) {
                    //向左走
                    current = current.left
                    isLeftChild = true;
                } else {
                    //向右走
                    current = current.right
                    isLeftChild = false;
                }
                //已经找到了最后的节点
                if (current == null) {
                    return false
                }
            }
            //找到了，根据情况删除节点  current.key = key  
            //1、删除节点没有子节点
            if (current.left == null && current.right == null) {
                if (current == this.root) {
                    this.root = null
                } else if (isLeftChild) {
                    parent.left = null
                } else {
                    parent.right = null
                }
            } else if (current.right == null) { //2、删除只有一个子节点
                //判断当前current是不是根
                if (current == this.root) {
                    this.root = current.left
                } else if (isLeftChild) {
                    parent.left = current.left
                } else {
                    parent.right = current.left
                }
            } else if (current.left == null) { //2、删除只有一个子节点
                if (current == this.root) {
                    this.root = current.right
                } else if (isLeftChild) {
                    parent.left = current.right
                } else {
                    parent.right = current.right
                }
            }
            //3、删除有两个子节点  找左子树的最大值（前驱），右子树最小值（后继）
            //前驱  后继
            else {
                // 1.获取后继节点
                var successor = this.getSuccessor(current)
                // 2.判断是否是根节点
                if (current == this.root) {
                    this.root = successor
                } else if (isLeftChild) {
                    parent.left = successor
                } else {
                    parent.right = successor
                }
                // 3.将删除节点的左子树赋值给successor
                successor.left = current.left
            }
        }
        // 找后继的方法
        BinarySerachTree.prototype.getSuccessor = function (delNode) {
            // 1.使用变量保存临时的节点
            var successorParent = delNode
            var successor = delNode
            var current = delNode.right // 要从右子树开始找
            // 2.寻找节点
            while (current != null) {
                successorParent = successor
                successor = current
                current = current.left
            }
            // 3.如果是删除图中15的情况, 还需要如下代码
            //判断寻找的后继节点是否直接是delNode的right节点
            if (successor != delNode.right) {
                successorParent.left = successor.right
                successor.right = delNode.right
            }
            return successor
        }
    }
</script>

</html>