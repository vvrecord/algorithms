### curd
对于数据而言存在多种操作，我们常常说的get和set就是获取值和设置值
从功能性上来说还存在可读和可写操作，但是数据结构所关注的更多的是插入、删除、修改、查找，也就是
我们常常说的CURD
### 数组同链表的对比
数组：尾部插入快，根据索引获取值，设置值快，连续空间添加或者删除效率低
链表：插入快，删除快，读取查找慢

### 栈
数组是线性结构，可以在任意位置插入或者删除数据
 
加以限制->栈和队列

也就是受限制的线性结构

栈：在栈顶操作，后进先出  LIFO   需要哪些方法呢？
1、入栈
2、出栈

递归：不断执行压栈，递归存在调用未完成因此未出栈，容易造成栈溢出，因此需要做判断跳出递归
```
function Stack(){
         this.items = [];
        //入栈
        Stack.prototype.push = function(item){
            this.items.push(item)
        }
        //出栈并获取该元素
        Stack.prototype.pop = function(){
            return this.items.pop()
        }
        //判断是否为空
        Stack.prototype.isEmpty = function(){
            return this.items.length == 0
        }
        //获取栈的长度
        Stack.prototype.size = function(){
            return this.items.length
        }
        //tostring
        Stack.prototype.toString = function(){
            var resultString = '';
            for(let i = 0;i<this.items.length;i++){
                resultString+=this.items[i]
            }
            return resultString
        }
        //获取栈顶元素
        Stack.prototype.getTop = function(){
            return this.items[this.items.length-1]
        }
    }
    //十进制转二进制
    function decTbin(number){
        var stack = new Stack()
        while(number>0){
            stack.push(number%2);
            number = Math.floor(number/2)
        }
        return stack.toString()
    }
    console.log(decTbin(100))
```
### 队列
队列：受限制的线性结构 先进先出 FIFO
表的前端执行删除
表的后端执行插入操作
例如：买票排队，先排队的人先处理，打印机，线程队列

注意队列方向
----->  自左到右   左边执行添加操作右边执行删除操作
<-----  自右到左   右边执行添加操作左边执行删除操作

实现方式：
基于数组
基于链表
```
function Queue(){
        //数组方向 <-----,push进去，shift出来
        this.items = []
        //队列尾部添加一个
        Queue.prototype.enter = function(item){
            this.items.push(item)
        }
        //移除队列头部项，并返回该移除项目
        Queue.prototype.leave = function(){
            return this.items.shift()
        }
        //返回队列第一个元素
        Queue.prototype.first = function(){
            return this.items[0]
        }
        //判断是否为空
        Queue.prototype.isEmpty = function(){
            return this.items.length ==0
        }
        //队列元素个数
        Queue.prototype.size = function(){
            return this.items.length
        }
        //tostring
        Queue.prototype.toString = function(){
            var resultString = '';
            for(let i = 0;i<this.items.length;i++){
                resultString+=this.items[i]
            }
            return resultString
        }
    }
```
#### 优先级队列
优先级队列再插入一个元素的时候考虑数据的优先级

需要考虑的问题：
1、每个元素的不只是单纯的数据项，需要考虑包含数据的优先级
2、添加的时候根据优先级放入正确的位置

优先级应用：
1、登机的顺序：商务舱高于经济舱
老人小孩和孕妇或者带小孩的乘客登机时候高于其他乘客
2、急症科根据优先级进行处理顺序
3、任务队列中根据优先级进行处理
```
    //数字越小优先级越高
    function PriorityQueue() {
        //构造数据项的内部构造函数
        function QueneItem(item, priority) {
            this.item = item;
            this.priority = priority;
        }
        //PriorityQueuene内部的属性
        this.items = [];
        //优先级队列插入方法
        PriorityQueue.prototype.enter = function (item, priority) {
            var queneItem = new QueneItem(item, priority);
            //获取传入元素的正确位置
            //1、判断队列是否为空
            if (this.isEmpty()) {
                this.items.push(queneItem);
            } else {
                let added = false;
                for (let i = 0; i < this.size(); i++) {
                    if (queneItem.priority < this.items[i].priority) {
                        this.items.splice(i, 0, queneItem);
                        added = true;
                        break;
                    }
                }
                if (!added) {
                    this.items.push(queneItem);
                }
            }
        }
        PriorityQueue.prototype.leave = function () {
            return this.items.shift();
        }
        //返回队列第一个元素
        PriorityQueue.prototype.first = function () {
            return this.items[0];
        }
        //判断是否为空
        PriorityQueue.prototype.isEmpty = function () {
            return this.items.length == 0;
        }
        //队列元素个数
        PriorityQueue.prototype.size = function () {
            return this.items.length;
        }
        //tostring
        PriorityQueue.prototype.toString = function () {
            var resultString = '';
            for (let i = 0; i < this.items.length; i++) {
                resultString += this.items[i].item;
            }
            return resultString;
        }
    }
```

### 链表
 数组优点：
 1、可以通过索引快速读取和设置元素
 数组缺点：
 1、需要申请一段连续的空间，并且大小是固定的，当不满足容量需要扩容
 2、在数组开头或者中间位置插入成本高，需要进行大量元素位移
 链表的优势：
 1、不必是连续的空间
 2、链表插入和删除的时候效率高时间复杂度可以达到O(1)
 缺点：
 1、访问任何一个元素必须从头开始访问
 2、无法通过下标直接访问直到找到对应的元素
  ```
   function LinkedList() {
        //内部类，节点类
        function Node(data) {
            this.data = data;
            this.next = null;
        }
        //头指针
        this.head = null;
        //记录当前链表的长度
        this.length = 0;
        //链表
        LinkedList.prototype.append = function (data) {
            //1、创建节点
            var node = new Node(data)
            //判断链表是否为空，如果是第一个节点直接插入，不是循环链表
            if (this.length == 0) {
                this.head = node //是第一个节点，直接把head指针指向该节点
            } else {
                var current = this.head; //此时head和current指向第一个节点，尽量别修改head指针位置
                while (current.next) { //表示节点不为空，一直循环到链表末尾
                    current = current.next;
                }
                current.next = node; //最后一个节点指向新创建的节点
            }
            this.length += 1;
        }
        //toString()
        LinkedList.prototype.toString = function () {
            var resultString = ''
            //循环链表
            var current = this.head;
            while (current) {
                resultString += current.data;
                current = current.next
            }
            return resultString;
        }
        //insert  1、越界判断
        LinkedList.prototype.insert = function (position, data) {
            if (position < 0 || position > this.length) return false
            //创建节点
            var node = new Node(data);
            //插入数据
            //是否是第一个
            if (position == 0) {
                node.next = this.head;
                this.head = node;
            } else {
                var index = 0;
                var current = this.head;
                var previous = null;
                while (index++ < position) {
                    previous = current;
                    current = current.next;
                }
                node.next = current;
                previous.next = node;
            }
            this.length += 1;
            return true;
        }
        //get
        LinkedList.prototype.get = function (position) {
            //等于length的时候为null
            if (position < 0 || position >= this.length) return false;
            var current = this.head;
            var index = 0;
            while (index++ < position) {
                current = current.next
            }
            return current.data
        }
        // indexOf(item)
        LinkedList.prototype.indexOf = function (item) {
            var current = this.head;
            var index = 0;
            while (current) {
                if (current.data == item) {
                    return index;
                }
                current = current.next;
                index += 1;
            }
            return -1;
        }
        //update
        LinkedList.prototype.update = function (position, data) {
            if (position < 0 || position >= this.length) return false; 
            var current = this.head;
            var index = 0;
            while (index++ < position) {
                current = current.next
            }
            current.data = data
            return true;
        }
        //removeAt
        LinkedList.prototype.removeAt = function(position){
            //越界判断
            if (position < 0 || position >= this.length) return false; 
            //删除的是第一个
            if(position==0){
                this.head = this.head.next;
            }else{
                var index = 0;
                var current = this.head;
                var previous = null;
                while(index++<position){
                    previous = current;
                    current = current.next
                }
                previous.next = current.next
            }
            this.length-=1;
            return true;
        }
        //remove
        LinkedList.prototype.remove = function(item){
            var position = this.indexOf(item);
            return this.removeAt(position)
        }
        //isEmpty
        LinkedList.prototype.isEmpty = function(){
            return this.length ==0;
        }
        //size
        LinkedList.prototype.size = function(){
            return this.length;
        }

    }
  ```
  ### 双向链表
  单向链表：
  只能从头遍历到尾或者从尾部到头部，相当于过程是单向的

  双向链表：
  数据项部分需要包含一个previous指针和一个next指针，分别指向前一个节点和下一个节点，以及本身数据项部分
  同时需要一个head指针和tail指针分别指向第一个或者最后一个节点
  ```
      function DoublyLinkedList() {
        //内部类，节点类
        function Node(data) {
            this.data = data;
            this.prev = null;
            this.next = null;
        }
        //头指针
        this.head = null;
        this.tail = null;
        //记录当前链表的长度
        this.length = 0;
        // 1.append
        DoublyLinkedList.prototype.append = function (data) {
            var node = new Node(data);
            // 2.判断链表是否为空
            if (this.head == null) {
                this.head = node;
                this.tail = node;
            } else {
                this.tail.next = node;
                node.prev = this.tail;
                this.tail = node;
            }
            // 3.length+1
            this.length++;
        }
        //2、toString()
        DoublyLinkedList.prototype.toString = function () {
            return this.backwardString()
        }
        //3、backwardString
        DoublyLinkedList.prototype.backwardString = function () {
            var resultString = '';
            var current = this.head;
            while (current) {
                resultString += current.data
                current = current.next
            }
            return resultString;
        }
        //4、forwardString
        DoublyLinkedList.prototype.forwardString = function () {
            var resultString = '';
            var current = this.tail;
            while (current) {
                resultString += current.data
                current = current.prev
            }
            return resultString;
        }
        //5、insert 特定位置插入新的节点
        DoublyLinkedList.prototype.insert = function (position, data) {
            //创建新节点
            var node = new Node(data)
            //越界判断
            if (position < 0 || position > this.length) return false
            //根据position查找位置
            if (this.length == 0) {
                //表示链表当前为空
                this.head = node;
                this.tail = node;
            } else {
                //插入到第一个位置
                if (position == 0) {
                    node.next = this.head;
                    this.head.prev = node;
                    this.head = node;
                } else if (position == this.length) {
                    this.tail.next = node;
                    node.prev = this.tail;
                    this.tail = node;
                } else {
                    var current = this.head
                    var index = 0;
                    while (index++ < position) {
                        current = current.next
                    }
                    //找到了正确的节点
                    node.next = current;
                    node.prev = current.prev;
                    current.prev.next = node
                    current.prev = node
                }
            }
            this.length += 1;
            return true
        }
        //get 获取某位置信息  同单向链表的方法
        DoublyLinkedList.prototype.get = function (position) {
            //越界判断
            if (position < 0 || position >= this.length) return null;
            //获取元素
            var current = this.head;
            var index = 0
            while (index++ < position) {
                current = current.next
            }
            return current.data;
        }
        //indexOf
        DoublyLinkedList.prototype.indexOf = function (item) {
            var current = this.head;
            var index = 0;
            while (current) {
                if (current.data == item) {
                    return index;
                }
                current = current.next;
                index += 1;
            }
            return -1;
        }
        DoublyLinkedList.prototype.update = function (position, data) {
            if (position < 0 || position >= this.length) return false;
            var current = this.head;
            var index = 0;
            while (index++ < position) {
                current = current.next;
            }
            current.data = data;
            return true;
        }
        //
        DoublyLinkedList.prototype.removeAt = function (position) {
            //越界判断
            if (position < 0 || position >= this.length) return null;
            //判断是否只有一个节点
            if (this.length == 1) {
                this.head = null;
                this.tail = null;
            } else {
                if (position == 0) {
                    this.head.next.prev = null;
                    this.head = this.head.next;
                } else if (position == this.length - 1) { //最后一个节点
                    this.tail.prev.next = null;
                    this.tail = this.tail.prev;
                } else {
                    var current = this.head;
                    var index = 0;
                    while (index++ < position) {
                        current = current.next;
                    }
                    //找到了，修改指针
                    current.prev.next = current.next;
                    current.next.prev = current.prev;
                }
            }
            this.length -= 1;
            return true;
        }
        //remove
        DoublyLinkedList.prototype.remove = function (item) {
            var position = this.indexOf(item);
            return this.removeAt(position)
        }
        //isEmpty
        DoublyLinkedList.prototype.isEmpty = function () {
            return this.length == 0;
        }
        //size
        DoublyLinkedList.prototype.size = function () {
            return this.length;
        }
    }
  ```

  ### 集合
  集合通常是无序的，不能重复
  ```
      //封装集合
    function Set() {
        this.items = {}
        Set.prototype.add = function(value){
            //判断是否存有该元素
            if(this.has(value)){
                return false
            }
            this.items[value] = value;
            return true
        }
        Set.prototype.has = function(value){
            return this.items.hasOwnProperty(value)
        }
        Set.prototype.remove = function(value){
            if(!this.has(value)){
                return false;
            }
            delete this.items[value];
            return true
        }
        Set.prototype.clear = function(){
            this.items = {}
        }
        Set.prototype.size = function(){
            return Object.keys(this.items).length
        }
        Set.prototype.values = function(){
            return Object.keys(this.items)
        }
        //并集union
        Set.prototype.union = function(target){
            //target 目标set
           var unionSet = new Set();
           for(let i = 0;i<this.values().length;i++){
            unionSet.add(this.values()[i])
           }
           for(let j = 0;j<target.values().length;j++){
            unionSet.add(target.values()[j])
           }
           return unionSet
        }
        //交集 intersection
        Set.prototype.intersection = function(target){
            var intersectionSet = new Set();
            var values = this.values();
           for(let i = 0;i<values.length;i++){
            if(target.has(values[i])){
                intersectionSet.add(values[i])
            }
           }
           return intersectionSet
        }
        //差集 diff
        Set.prototype.diff = function(target){
            var diffSet = new Set();
            var values = this.values()
           for(let i = 0;i<values.length;i++){
            if(!target.has(values[i])){
                diffSet.add(values[i])
            }
           }
           return diffSet
        }
        //子集 subset  判断是不是目标子集
        Set.prototype.subset = function(target){
            var values = this.values();
            for(let i = 0;i<values.length;i++){
            if(!target.has(values[i])){
                return false;
            }
           }
           return true;
        }

    }
  ```
  ### 字典
  主要特点：对应关系
  例如汉字的对应表，也就是日常的字典可以根据拼音进行查找对应的汉字
  通过key和value形式表示
  字典里面的key是不重复的，同时key是无序的
  
  字典和映射的关系：
  例如python里面dict，把这种映射关系为字典
  而java中hashmap和treemap则被作为Map（映射）

  数组和字典：
  字典可以方便的通过key来搜索对应的value，同时key一般具有一定的含义容易被记住

  字典和对象：
  java中字典和对象区别明显，对象通常编译期间就确定下来的结构，不可以动态添加和删除属性，而字典通常使用类似于哈希表的数据结构去
  实现动态添加
  JavaScript中对象类似于于一种字典，因此可以通过对象来模拟字典,例如我们上节实现的Set
  ```
  // 创建字典的构造函数
function Dictionay() {
    // 字典属性
    this.items = {}

    // 字典操作方法
    // 在字典中添加键值对
    Dictionay.prototype.set = function (key, value) {
        this.items[key] = value
    }

    // 判断字典中是否有某个key
    Dictionay.prototype.has = function (key) {
        return this.items.hasOwnProperty(key)
    }

    // 从字典中移除元素
    Dictionay.prototype.remove = function (key) {
        // 1.判断字典中是否有这个key
        if (!this.has(key)) return false

        // 2.从字典中删除key
        delete this.items[key]
        return true
    }

    // 根据key去获取value
    Dictionay.prototype.get = function (key) {
        return this.has(key) ? this.items[key] : undefined
    }

    // 获取所有的keys
    Dictionay.prototype.keys = function () {
        return Object.keys(this.items)
    }

    // 获取所有的value
    Dictionay.prototype.values = function () {
        return Object.values(this.items)
    }

    // size方法
    Dictionay.prototype.size = function () {
        return this.keys().length
    }

    // clear方法
    Dictionay.prototype.clear = function () {
        this.items = {}
    }
}
  ```

  ### 哈希表
哈希表是一种非常重要的数据结构, 几乎所有的编程语言都有直接或者间接的应用这种数据结构.

哈希表通常是基于数组进行实现的, 但是相对于数组, 它也很多的优势:
它可以提供非常快速的插入-删除-查找操作
无论多少数据, 插入和删除值需要接近常量的时间: 即O(1)的时间级. 实际上, 只需要几个机器指令即可
哈希表的速度比树还要快, 基本可以瞬间查找到想要的元素
哈希表相对于树来说编码要容易很多.
哈希表的不足:
哈希表中的数据是没有顺序的, 所以不能以一种固定的方式(比如从小到大)来遍历其中的元素.
通常情况下, 哈希表中的key是不允许重复的, 不能放置相同的key, 用于保存不同的元素.

结构就是数组，通过下标值变换（哈希函数）获取到HashCode


幂的连乘->产生唯一值->数字巨大导致空间的浪费

需要一种压缩算法，进行数据压缩。简单的方法使用取余操作

冲突：通过相对较好的哈希函数依然存在冲突，虽然概率极小但是也可能发生（也就是下标出现重复）
两种方案：
1、链地址法
2、开放地址法:
寻找空白的位置来放置冲突的数据
例如：线性探测、二次探测、在哈希法
       |
       ->容易产生聚集，从而需要不断查找影响哈希表性能，线性探测步长为1

         二次探测：对步长做优化，例如下标x开始，x+1^2,x+2^2,相当于一次性探测比较长的距离，容易产生步长不一致的聚集
                    再哈希法：依赖关键字探测序列，不同的关键字映射到相同的数组下标也可以使用不同的探测序列
                              关键字将另外一个哈希函数再做一次哈希，这次哈希结果作为步长。因此和第一个哈希函数不同，不能输出为0
                              例如：stepSize = const -（key%const） const为质数常量小于数组容量
删除时候不能将数据项设置为null，应该将数据设置为-1

优秀的哈希函数：
1、快速计算
霍纳算法

幂的连成属于一个多项式计算
在前面, 我们计算哈希值的时候使用的方式
cats = 3*27³+1*27²+20*27+17= 60337
这种方式是直观的计算结果, 那么这种计算方式会进行几次乘法几次加法呢? 当然, 我们可能不止4项, 可能有更多项
我们抽象一下, 这个表达式其实是一个多项式: a(n)xn+a(n-1)x(n-1)+…+a(1)x+a(0)
现在问题就变成了多项式有多少次乘法和加法:
乘法次数: n＋(n－1)＋…＋1＝n(n+1)/2
加法次数: n次
多项式的优化: 霍纳法则
解决这类求值问题的高效算法――霍纳法则。在中国，霍纳法则也被称为秦九韶算法。
通过如下变换我们可以得到一种快得多的算法，即Pn(x)= anx n+a(n－1)x(n-1)+…+a1x+a0=((…(((anx +an－1)x+an－2)x+ an－3)…)x+a1)x+a0，这种求值的安排我们称为霍纳法则。
变换后, 我们需要多少次乘法, 多少次加法呢?
乘法次数: N次
加法次数: N次.
如果使用大O表示时间复杂度的话, 我们直接从O(N²)降到了O(N)

2、均匀的分布
均匀的分布
在设计哈希表时, 我们已经有办法处理映射到相同下标值的情况: 链地址法或者开放地址法.
但是, 为了提供效率, 最好的情况还是让数据在哈希表中均匀分布.
因此, 我们需要在使用常量的地方, 尽量使用质数.
哪些地方我们会使用到常量呢?
质数的使用:
哈希表的长度.
N次幂的底数(我们之前使用的是27)
下面我们简单来说一下为什么.
哈希表的长度使用质数:
这个在链地址法中事实上重要性不是特别明显, 明显的是在开放地址法中的再哈希法中.
再哈希法中质数的重要性:
假设表的容量不是质数, 例如: 表长为15(下标值0~14)
有一个特定关键字映射到0, 步长为5. 探测序列是多少呢?
0 - 5 - 10 - 0 - 5 - 10, 依次类推, 循环下去.
算法只尝试着三个单元, 如果这三个单元已经有了数据, 那么会一直循环下去, 知道程序崩溃.
如果容量是一个质数, 比如13. 探测序列是多少呢?
0 - 5 - 10 - 2 - 7 - 12 - 4 - 9 - 1 - 6 - 11 - 3, 一直这样下去.
不仅不会产生循环, 而且可以让数据在哈希表中更加均匀的分布.
链地址法中质数没有那么重要, 甚至在Java中故意是2的N次幂
Java中的哈希表采用的是链地址法.
HashMap的初始长度是16, 每次自动扩展(我们还没有聊到扩展的话题), 长度必须是2的次幂.
这是为了服务于从Key映射到index的算法.
HashMap中为了提高效率, 采用了位运算的方式.
HashMap中index的计算公式: index = HashCode（Key） & （Length - 1）
比如计算book的hashcode，结果为十进制的3029737，二进制的101110001110101110 1001
假定HashMap长度是默认的16，计算Length-1的结果为十进制的15，二进制的1111
假定HashMap长度是默认的16，计算Length-1的结果为十进制的15，二进制的1111
把以上两个结果做与运算，101110001110101110 1001 & 1111 = 1001，十进制是9，所以 index=9
这样的方式相对于取模来说性能是高的, 因为计算机更运算计算二进制的数据.
但是, 我个人发现JavaScript中进行较大数据的位运算时会出问题, 所以我的代码实现中还是使用了取模.
N次幂的底数, 使用质数:
这里采用质数的原因是为了产生的数据不按照某种规律递增.
比如我们这里有一组数据是按照4进行递增的: 0 4 8 12 16, 将其映射到成都为8的哈希表中.
它们的位置是多少呢? 0 - 4 - 0 - 4, 依次类推.
如果我们哈希表本身不是质数, 而我们递增的数量可以使用质数, 比如5, 那么 0 5 10 15 20
它们的位置是多少呢? 0 - 5 - 2 - 7 - 4, 依次类推. 也可以尽量让数据均匀的分布.
我们之前使用的是27, 这次可以使用一个接近的数, 比如31/37/41等等. 一个比较常用的数是37.

```
function hashFunc(str, max) {
    // 1.初始化hashCode的值
    var hashCode = 0

    // 2.霍纳算法, 来计算hashCode的数值
    for (var i = 0; i < str.length; i++) {
        hashCode = 37 * hashCode + str.charCodeAt(i)
    }

    // 3.取模运算
    hashCode = hashCode % max
    return hashCode
}


// 创建HashTable构造函数
function HashTable() {
    // 定义属性
    this.storage = []
    this.count = 0
    this.limit = 8

    // 定义相关方法
    // 哈希函数
    HashTable.prototype.hashFunc = function(str, max) {
        // 1.初始化hashCode的值
        var hashCode = 0

        // 2.霍纳算法, 来计算hashCode的数值
        for (var i = 0; i < str.length; i++) {
            hashCode = 37 * hashCode + str.charCodeAt(i)
        }
      
        // 3.取模运算
        hashCode = hashCode % max
        return hashCode
      }
}

// 插入数据方法
HashTable.prototype.put = function (key, value) {
    // 1.获取key对应的index
    var index = this.hashFunc(key, this.limit)

    // 2.取出数组(也可以使用链表)
    var bucket = this.storage[index]

    // 3.判断这个数组是否存在
    if (bucket === undefined) {
        // 3.1创建桶
        bucket = []
        this.storage[index] = bucket
    }
    alert(bucket)
    
    // 4.判断是新增还是修改原来的值.
    var override = false
    for (var i = 0; i < bucket.length; i++) {
        var tuple = bucket[i]
        if (tuple[0] === key) {
            tuple[1] = value
            override = true
        }
    }
    
    // 5.如果是新增, 前一步没有覆盖
    if (!override) {
        bucket.push([key, value])
        this.count++
    }
}


// 获取存放的数据
HashTable.prototype.get = function (key) {
    // 1.获取key对应的index
    var index = this.hashFunc(key, this.limit)

    // 2.获取对应的bucket
    var bucket = this.storage[index]

    // 3.如果bucket为null, 那么说明这个位置没有数据
    if (bucket == null) {
        return null
    }

    // 4.有bucket, 判断是否有对应的key
    for (var i = 0; i < bucket.length; i++) {
        var tuple = bucket[i]
        if (tuple[0] === key) {
            return tuple[1]
        }
    }
    
    // 5.没有找到, return null
    return null
}

// 删除数据
HashTable.prototype.remove = function (key) {
    // 1.获取key对应的index
    var index = this.hashFunc(key, this.limit)
    
    // 2.获取对应的bucket
    var bucket = this.storage[index]
    
    // 3.判断同是否为null, 为null则说明没有对应的数据
    if (bucket == null) {
        return null
    }
    
    // 4.遍历bucket, 寻找对应的数据
    for (var i = 0; i < bucket.length; i++) {
        var tuple = bucket[i]
        if (tuple[0] === key) {
            bucket.splice(i, 1)
            this.count--
            return tuple[1]
        }
    }
    
    // 5.来到该位置, 说明没有对应的数据, 那么返回null
    return null
}

// isEmpty方法
HashTable.prototype.isEmpty = function () {
    return this.count == 0
}
// size方法
HashTable.prototype.size = function () {
    return this.count
}

```

哈希表扩容的思想
为什么需要扩容?
目前, 我们是将所有的数据项放在长度为8的数组中的.
因为我们使用的是链地址法, loadFactor可以大于1, 所以这个哈希表可以无限制的插入新数据.
但是, 随着数据量的增多, 每一个index对应的bucket会越来越长, 也就造成效率的降低.
所以, 在合适的情况对数组进行扩容. 比如扩容两倍.
如何进行扩容?
扩容可以简单的将容量增加大两倍(不是质数吗? 质数的问题后面再讨论)
但是这种情况下, 所有的数据项一定要同时进行修改(重新哈希化, 来获取到不同的位置)
比如hashCode=12的数据项, 在length=8的时候, index=4. 在长度为16的时候呢? index=12.
这是一个耗时的过程, 但是如果数组需要扩容, 那么这个过程是必要的.
什么情况下扩容呢?
比较常见的情况是loadFactor>0.75的时候进行扩容.
比如Java的哈希表就是在装填因子大于0.75的时候, 对哈希表进行扩容.
```
// 哈希表扩容
HashTable.prototype.resize = function (newLimit) {
    // 1.保存旧的数组内容
    var oldStorage = this.storage

    // 2.重置属性
    this.limit = newLimit
    this.count = 0
    this.storage = []

    // 3.遍历旧数组中的所有数据项, 并且重新插入到哈希表中
    oldStorage.forEach(function (bucket) {
        // 1.bucket为null, 说明这里面没有数据
        if (bucket == null) {
            return
        }

        // 2.bucket中有数据, 那么将里面的数据重新哈希化插入
        for (var i = 0; i < bucket.length; i++) {
            var tuple = bucket[i]
            this.put(tuple[0], tuple[1])
        }
    }.bind(this))
}

在什么时候调用扩容方法呢?

在每次添加完新的数据时, 都进行判断. (也就是put方法中)
修改put方法

代码第5步中的内容
// 插入数据方法
HashTable.prototype.put = function (key, value) {
    // 1.获取key对应的index
    var index = this.hashFunc(key, this.limit)

    // 2.取出数组(也可以使用链表)
    // 数组中放置数据的方式: [[ [k,v], [k,v], [k,v] ] , [ [k,v], [k,v] ]  [ [k,v] ] ]
    var bucket = this.storage[index]

    // 3.判断这个数组是否存在
    if (bucket === undefined) {
        // 3.1创建桶
        bucket = []
        this.storage[index] = bucket
    }

    // 4.判断是新增还是修改原来的值.
    var override = false
    for (var i = 0; i < bucket.length; i++) {
        var tuple = bucket[i]
        if (tuple[0] === key) {
            tuple[1] = value
            override = true
        }
    }

    // 5.如果是新增, 前一步没有覆盖
    if (!override) {
        bucket.push([key, value])
        this.count++
        // 数组扩容
        if (this.count > this.limit * 0.75) {
            this.resize(this.limit * 2)
        }
    }
}
如果我们不断的删除数据呢?

如果不断的删除数据, 当loadFactor < 0.25的时候, 最好将数量限制在一半.
修改remove方法

代码第4步中的内容

// 删除数据
HashTable.prototype.remove = function (key) {
    // 1.获取key对应的index
    var index = this.hashFunc(key, this.limit)

    // 2.获取对应的bucket
    var bucket = this.storage[index]

    // 3.判断同是否为null, 为null则说明没有对应的数据
    if (bucket == null) {
        return null
    }

    // 4.遍历bucket, 寻找对应的数据
    for (var i = 0; i < bucket.length; i++) {
        var tuple = bucket[i]
        if (tuple[0] === key) {
            bucket.splice(i, 1)
            this.count--
            
            // 缩小数组的容量
            if (this.limit > 8 && this.count < this.limit * 0.25) {
                this.resize(Math.floor(this.limit / 2))
            }
        }
        return tuple[1]
    }

    // 5.来到该位置, 说明没有对应的数据, 那么返回null
    return null
}
判断质数：
function isPrime(num) {
    // 1.获取平方根
    var temp = parseInt(Math.sqrt(num))

    // 2.循环判断
    for (var i = 2; i <= temp; i++) {
        if (num % i == 0) {
            return false
        }
    }
    return true
}
扩容的质数：

// 判断是否是质数
HashTable.prototype.isPrime = function (num) {
    var temp = parseInt(Math.sqrt(num))
    // 2.循环判断
    for (var i = 2; i <= temp; i++) {
        if (num % i == 0) {
            return false
        }
    }
    return true
}


// 获取质数
HashTable.prototype.getPrime = function (num) {
    while (!isPrime(num)) {
        num++
    }
    return num
}

修改插入和删除的代码:

// 扩容数组的数量
if (this.count > this.limit * 0.75) {
    var primeNum = this.getPrime(this.limit * 2)
    this.resize(primeNum)
}
// 缩小数组的容量
if (this.limit > 7 && this.count < this.limit * 0.25) {
    var primeNum = this.getPrime(Math.floor(this.limit / 2))
    this.resize(primeNum)
}

hash完整代码

// 创建HashTable构造函数
function HashTable() {
    // 定义属性
    this.storage = []
    this.count = 0
    this.limit = 8

    // 定义相关方法
    // 判断是否是质数
    HashTable.prototype.isPrime = function (num) {
        var temp = parseInt(Math.sqrt(num))
        // 2.循环判断
        for (var i = 2; i <= temp; i++) {
            if (num % i == 0) {
                return false
            }
        }
        return true
    }

    // 获取质数
    HashTable.prototype.getPrime = function (num) {
        while (!isPrime(num)) {
            num++
        }
        return num
    }
```

### 树
树的术语:
1.结点的度（Degree）：结点的子树个数.
2.树的度：树的所有结点中最大的度数. (树的度通常为结点的个数N-1)
3.叶结点（Leaf）：度为0的结点. (也称为叶子结点)
4.父结点（Parent）：有子树的结点是其子树的根结点的父结点
5.子结点（Child）：若A结点是B结点的父结点，则称B结点是A结点的子结点；子结点也称孩子结点。
6.兄弟结点（Sibling）：具有同一父结点的各结点彼此是兄弟结点。
7.路径和路径长度：从结点n1到nk的路径为一个结点序列n1 , n2,… , nk, ni是 ni+1的父结点。路径所包含边的个数为路径的长度。
8.结点的层次（Level）：规定根结点在1层，其它任一结点的层数是其父结点的层数加1。
9.树的深度（Depth）：树中所有结点中的最大层次是这棵树的深度

二叉树重要的特性：
第i层最大节点数为：2^(i-1)  i>=1
深度为k的最大节点数量：2^k-1    k>=1

二叉搜素树
1、非空左子树所有键值小于其根节点
2、非空右子树所有键值大于其根节点  
3、左右子树本身也是二叉搜素树

遍历：
先序遍历
1、访问根节点
2、先序遍历左子树
3、先序遍历右子树
中序遍历
1、中序遍历其左子树；
2、访问根结点；
3、中序遍历其右子树。
后序遍历
1、中序遍历其左子树；
2、中序遍历其右子树。
3、访问根结点；
层序遍历

### 红黑树(难点)

1、节点是红色或黑色
2、根节点是黑色
3、每个叶子节点都是黑色的空节点（NIL节点）
4、每个红色节点的两个字节点都是黑色（从每个叶子到根的路径不能有连续的红色节点）
5、从任一个节点到其每个叶子的所有路径都包含相同数目的黑色节点

关键特性：
从根到叶子最长可能路径，不会超过最短可能路径的两倍长->相对平衡
性质4决定了路径不可能有两个相连的红色节点
最短的可能路径都是黑色节点
最长的可能路径都是红色和黑色交替
性质5所有路径都投相同数目的黑色节点
所以没有路径能够超出其他路径的两倍长

维持红黑树平衡
1、变色
2、左旋转
3、右旋转

### 图
